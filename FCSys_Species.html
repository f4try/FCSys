<html>
<head>
<title>FCSys.Species</title>
<meta name="title" content="Modelica fuel cell library">
<meta name="keywords" content="fuel cell library, FCSys, fuel cell, PEM, proton exchange membrane, polymer exchange membrane, PEMFC, Modelica, Dymola, open-source, electrochemistry">
<meta name="date" content="2014-1-23">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Dynamic models of chemical species">
<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="stylesheets/ModelicaDoc.css">
<link rel="shortcut icon" href="images/favicon.ico">
<script type="text/javascript" src="javascripts/analytics.js"></script>
</head>
<body>
<span itemscope itemtype="http://schema.org/SoftwareApplication">
<div class="sidebar">
  <div class="sidebarwrapper">
  <a href="index.html">

<h2>FCSys</h2>

</a>
  <p align=center><a href="index.html">
    <img src="images/icon.gif" alt="Logo" width=150>
  </a></p>

<h3>Table of Contents</h3>

<ul>
    <li><a href="FCSys_UsersGuide.html">User's Guide</a></li>
    <li><a href="FCSys_Blocks.html">Blocks</a></li>
    <li><a href="FCSys_Conditions.html">Conditions</a></li>
    <li><a href="FCSys_Assemblies.html">Assemblies</a></li>
    <li><a href="FCSys_Regions.html">Regions</a></li>
    <li><a href="FCSys_Subregions.html">Subregions</a></li>
    <li><a href="FCSys_Phases.html">Phases</a></li>
    <li><a href="FCSys_Species.html">Species</a></li>
    <li><a href="FCSys_Chemistry.html">Chemistry</a></li>
    <li><a href="FCSys_Connectors.html">Connectors</a></li>
    <li><a href="FCSys_Characteristics.html">Characteristics</a></li>
    <li><a href="FCSys_Units.html">Units</a></li>
    <li><a href="FCSys_Quantities.html">Quantities</a></li>
    <li><a href="FCSys_Utilities.html">Utilities</a></li>
    <li><a href="FCSys_Icons.html">Icons</a></li>
    </ul>

  <h3>Download</h3>
    <ul>
      <li><span itemprop="downloadUrl">Latest: <a href="https://github.com/kdavies4/FCSys/archive/v0.2.5.zip">v0.2.5</a> (2014-01-23)</span></li>
    </ul>
  </div>
</div>

<div class="document">
  <div class="documentwrapper">
    <div class="bodywrapper">
      <div class="body">

<h2><a name="FCSys.Species"></a><a href="index.html#FCSys">FCSys</a>.Species</h2>

<b>Dynamic models of chemical species</b>

<h3>Information</h3>

Extends from <a href="file:///C:/Program Files (x86)/Dymola 2014/Modelica/Library/Modelica 3.2.1/help/Modelica_Icons_Package.html#Modelica.Icons.Package">Modelica.Icons.Package</a> (Icon for standard packages).

<h3>Package Content</h3>

<table border=1 cellspacing=0 cellpadding=2 >
<tr><th>Name</th><th>Description</th></tr>
<tr><td><img src="images/FCSys.Species.'C+'S.png" alt="FCSys.Species.'C+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_'C+'.html#FCSys.Species.'C+'">'C+'</a>
</td><td>C</td></tr>
<tr><td><img src="images/FCSys.Species.'C+'S.png" alt="FCSys.Species.'SO3-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_'SO3-'.html#FCSys.Species.'SO3-'">'SO3-'</a>
</td><td>C<sub>19</sub>HF<sub>37</sub>O<sub>5</sub>S<sup>-</sup> (abbreviated as SO<sub>3</sub><sup>-</sup>)</td></tr>
<tr><td><img src="images/FCSys.Species.'C+'S.png" alt="FCSys.Species.'e-'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_'e-'.html#FCSys.Species.'e-'">'e-'</a>
</td><td>e<sup>-</sup></td></tr>
<tr><td><img src="images/FCSys.Species.'C+'S.png" alt="FCSys.Species.'H+'" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_'H+'.html#FCSys.Species.'H+'">'H+'</a>
</td><td>H<sup>+</sup></td></tr>
<tr><td><img src="images/FCSys.Species.'C+'S.png" alt="FCSys.Species.H2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_H2.html#FCSys.Species.H2">H2</a>
</td><td>H<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Species.'C+'S.png" alt="FCSys.Species.H2O" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_H2O.html#FCSys.Species.H2O">H2O</a>
</td><td>H<sub>2</sub>O</td></tr>
<tr><td><img src="images/FCSys.Species.'C+'S.png" alt="FCSys.Species.N2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_N2.html#FCSys.Species.N2">N2</a>
</td><td>N<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Species.'C+'S.png" alt="FCSys.Species.O2" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_O2.html#FCSys.Species.O2">O2</a>
</td><td>O<sub>2</sub></td></tr>
<tr><td><img src="images/FCSys.Species.IonS.png" alt="FCSys.Species.Ion" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species.html#FCSys.Species.Ion">Ion</a>
</td><td>Base model for an ion</td></tr>
<tr><td><img src="images/FCSys.Species.IonS.png" alt="FCSys.Species.Fluid" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species.html#FCSys.Species.Fluid">Fluid</a>
</td><td>Base model for a fluid species</td></tr>
<tr><td><img src="images/FCSys.Species.SolidS.png" alt="FCSys.Species.Solid" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species.html#FCSys.Species.Solid">Solid</a>
</td><td>Base model for an inert, stationary solid</td></tr>
<tr><td><img src="images/FCSys.Species.SpeciesS.png" alt="FCSys.Species.Species" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species.html#FCSys.Species.Species">Species</a>
</td><td>Base model for one chemical species in one phase</td></tr>
<tr><td><img src="images/FCSys.Species.EnumerationsS.png" alt="FCSys.Species.Enumerations" width=20  height=20 align=top>&nbsp;<a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations">Enumerations</a>
</td><td>Choices of options</td></tr>
</table>
<hr>

<h2><img src="images/FCSys.Species.IonI.png" alt="FCSys.Species.Ion" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Species.Ion"></a><a href="FCSys_Species.html#FCSys.Species">FCSys.Species</a>.Ion</h2>
<b>Base model for an ion</b>
<img src="images/FCSys.Species.IonD.png" alt="FCSys.Species.Ion">

<h3>Information</h3>

<p>Please see the
     <a href="FCSys_Species.html#FCSys.Species.Fluid">Fluid</a> model.</p>
Extends from <a href="FCSys_Species.html#FCSys.Species.Fluid">Fluid</a> (Base model for a fluid species).
<p>

<h3>Parameters</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<tr><td>Integer</td><td>n_inter</td><td>0</td><td>Number of exchange connections with other phases</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristics.BaseClasses&hellip;.</td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Mobility</a></td><td>mu</td><td>sigma*v</td><td>Mobility [N.T/M]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>nu</td><td>Data.nu(T, v)</td><td>Thermal independity [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.DiffusivityMassSpecific">DiffusivityMassSpecific</a></td><td>zeta</td><td>Data.zeta(T, v)</td><td>** [L2.M/(N.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>eta</td><td>Data.eta(T, v)</td><td>Fluidity [L.T/M]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>theta</td><td>Data.theta(T, v)</td><td>Thermal resistivity [L.T/N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ConductivityElectrical">ConductivityElectrical</a></td><td>sigma</td><td>Data.mu()/Data.v_Tp()</td><td>Electrical conductivity [N2.T/(L3.M)]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Independence factors</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k_intra_Phi[n_intra, n_trans]</td><td>ones(n_intra, n_trans)</td><td>For translational exchange among species within the phase [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k_intra_Q[n_intra]</td><td>ones(n_intra)</td><td>For thermal exchange among species within the phase [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi.start[n_trans]</td><td>0</td><td>Velocity [L/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Current">Current</a></td><td>I.start[n_trans]</td><td>0</td><td>Current [N/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi_boundaries.start[n_trans, Side]</td><td>0</td><td>Normal velocities at the boundaries [L/T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Force</a></td><td>f.start[n_trans]</td><td>0</td><td>Total normal translational force on pairs of boundaries [L.M/T2]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Force</a></td><td>minusDeltaf.start[n_trans]</td><td>0</td><td>Dynamic and nonequilibrium compression forces [L.M/T2]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Chemical parameters</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>tauprime[n_chem]</td><td>zeros(n_chem)</td><td>Specific exchange currents [T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>kL[:]</td><td>L[cartTrans]</td><td>Effective transport length [L]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.Init">Init</a></td><td>initMaterial</td><td>Init.pressure</td><td>Method of initializing the material state</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.Init">Init</a></td><td>initEnergy</td><td>Init.temperature</td><td>Method of initializing the thermal state</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial amount of material [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Density</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial density [N/L3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume [L3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure [M/(L.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature [L2.M/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy [L2.M/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>g_IC</td><td>&nbsp;</td><td>Initial Gibbs potential [L2.M/(N.T2)]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Integer</td><td>n_trans</td><td>1</td><td>Number of transport axes</td></tr>
<tr><td>Integer</td><td>n_chem</td><td>0</td><td>Number of reaction and phase change processes</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Formulation of the conservation equations</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsThermo">ConsThermo</a></td><td>consMaterial</td><td>ConsThermo.dynamic</td><td>Material</td></tr>
<tr><td>Boolean</td><td>consRot</td><td>false</td><td>Conserve rotational momentum</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a></td><td>consTransX</td><td>ConsTrans.dynamic</td><td>X-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a></td><td>consTransY</td><td>ConsTrans.dynamic</td><td>Y-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a></td><td>consTransZ</td><td>ConsTrans.dynamic</td><td>Z-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsThermo">ConsThermo</a></td><td>consEnergy</td><td>ConsThermo.dynamic</td><td>Energy</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Flow conditions</td></tr>
<tr><td>Boolean</td><td>approxVelocity</td><td>true</td><td>Calculate normal boundary velocities assuming uniform density</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Phi[Axis]</td><td>{4,4,4}</td><td>Translational Nusselt numbers [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Q</td><td>1</td><td>Thermal Nusselt number [1]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Advanced</b></td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N0</td><td>0</td><td>Nominal amount of material to prevent depletion [N]</td></tr>
</table>
<p>

<h3>Connectors</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Intra">Intra</a></td><td>intra[n_intra]</td><td>Connectors to exchange translational momentum and energy within the phase</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inter">Inter</a></td><td>inter[n_inter]</td><td>Connectors to exchange translational momentum and energy with all other species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Dalton">Dalton</a></td><td>dalton</td><td>Connector for additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Boundary">Boundary</a></td><td>boundaries[n_trans, Side]</td><td>Connectors for transport</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Chemical</a></td><td>chemical[n_chem]</td><td>Connector for reactions and phase change</td></tr>
</table>

<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> Ion <font color="darkgreen">&quot;Base model for an ion&quot;</font>
  <font color="blue">import </font>assert = <a href="FCSys_Utilities.html#FCSys.Utilities.assertEval">FCSys.Utilities.assertEval</a>;
  <font color="blue">extends </font><a href="FCSys_Species.html#FCSys.Species.Fluid">Fluid</a>(<font color="blue">final </font>mu=sigma*v, N(stateSelect=StateSelect.default));

  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.ConductivityElectrical">Q.ConductivityElectrical</a> sigma=<font color="red">Data.mu</font>()/<font color="red">Data.v_Tp</font>() <font color="darkgreen">
    &quot;Electrical conductivity&quot;</font>;

<font color="blue">end </font>Ion;
</pre>
<hr>

<h2><img src="images/FCSys.Species.IonI.png" alt="FCSys.Species.Fluid" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Species.Fluid"></a><a href="FCSys_Species.html#FCSys.Species">FCSys.Species</a>.Fluid</h2>
<b>Base model for a fluid species</b>
<img src="images/FCSys.Species.IonD.png" alt="FCSys.Species.Fluid">

<h3>Information</h3>

<p>Fixed assumptions:</p><ol>
    <li>The gradient of material current is uniform in the direction of the current.</li>
    <li>The normal translational force on pairs of boundaries is split equally between the boundaries.  This includes
    the body, shear (transverse translational transport), and exchange forces due to intermolecular drag and transfer during

    chemical reactions and phase change.  It excludes the thermodynamic, dynamic

    (advective normal translational transport), and nonequilibrium (irreversible compression) pressures.  It also excludes

    transient effects since translational momentum is stored at the boundaries (not in the subregion).</li>

    <li>Nonequilibrium pressure is included in the thermodynamic states at the boundaries.  In particular, the specific enthalpy at a boundary

    is a function of the temperature and the

    sum of the thermodynamic and nonequilibrium pressures at the boundary (and a possible artifact of dynamic pressure; see the first note regarding parameters).

    The rate of advection of energy is the product of this
    specific enthalpy and the material current.
    </ol>

    <p>Notes regarding the parameters:</p>
    <ol>

    <li>If <code>approxVelocity</code> is <code>true</code>,
    then the normal velocities at the boundaries are calculated from the boundary currents assuming
    that the density is uniform.  This

    avoids nonlinear systems of equations, but it introduces an artifact of the dynamic pressure into the

    thermodynamic states at the boundaries.  The extra pressure is <i>m</i>&nbsp;<i>N&#775;<sub>i</sub></i><sup>2</sup>&nbsp;(<i>v</i> - <i>v<sub>i</sub></i>)/<i>A</i>&prime;, where <i>m</i> is the specific mass,

    <i>v</i> is the specific volume in the subregion,

    <i>v<sub>i</sub></i> is the specific volume at the boundary, <i>N&#775;<sub>i</sub></i> is the boundary current, and
    <i>A</i>&prime; is the available cross-sectional area.
    This affects the energy balance via the specific enthalpy at the boundaries.</li>

    <li>If <code>consTransX</code>, <code>consTransY</code>, or <code>consTransZ</code> is
    <code>ConsTrans.steady</code>, then the derivative of translational momentum at and normal to the boundaries (proportional to
    &part;<i>N&#775;<sub>i</sub></i>/&part;<i>t</i>)

    is treated as zero and removed from the translational momentum balances/material transport equations
    at the corresponding boundaries.</li>

    <li>If consRot is <code>true</code>, then rotational momentum is conserved without storage
    (i.e., steady).  This means that the shear forces are mapped so that there is no net torque around any
    rotational axis that has all its boundaries included (i.e., all the boundaries around the perimeter).  Rotational

    momentum is not exchanged among species or directly transported (i.e., uniform or shaft rotation).</li>

    <li>Upstream discretization is applied by default.
    The central difference
    scheme may be used by setting <code>upstreamX</code>, <code>upstreamY</code>, and <code>upstreamZ</code> to

    <code>true</code>.  The typical diffusion properties are such that the P&eacute;clet number for

    the upstream discretization of pressure will be much less (factor of 1/10,000) than the

    P&eacute;clet numbers for translational and thermal transport.  Therefore, it may appear
    that pressure is not advected with the material transport stream.</li>

    <li>The indices of the translational Nusselt number (<i>Nu</i><sub>&Phi;</sub>)
    correspond to the orientation of the translational momentum that is transported, not the axes of material transport.</li>

    <li>The default thermal Nusselt number is one, which represents pure conduction through the gas.  Use

    3.66 for internal flow where the boundaries are uniform in temperature or 48/11 (approximately 4.36)

    if the heat flux is uniform [<a href="FCSys_UsersGuide_References.html#FCSys.UsersGuide.References.Incropera2002">Incropera2002</a>].</li>

    </ol>

    <p>Translational momentum and thermal energy are advected as material is exchanged
    due to phase change and reactions.  This occurs at the velocity (&phi;) and the specific entropy-temperature
    product (<i>sT</i>) of the reactants (source configurations), where the reactant/product designation
    depends on the current conditions.</p>

    <p>The advective exchange is modeled via a <code>stream</code> connector
    (<a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Chemical</a>).
  The rate of advection of translational momentum is the
  product of the velocity of the source (&phi;) and the mass flow rate
  (<i>M&#775;</i> or <i>m</i><i>N&#775;</i>).  The rate of thermal advection is the
  specific entropy-temperature product of the source (<i>sT</i>) times the rate of
  material exchange
  (<i>N&#775;</i>).  If there are multiple sources, then
  their contributions are additive.  If there are multiple sinks, then
  translational momentum is split on a mass basis and the thermal stream is split
  on a particle-number basis.</p>

    <p>For more information, please see the
     <a href="FCSys_Species.html#FCSys.Species.Species">Species</a> model.</p>

Extends from <a href="FCSys_Species.html#FCSys.Species.Species">Species</a> (Base model for one chemical species in one phase).
<p>

<h3>Parameters</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<tr><td>Integer</td><td>n_inter</td><td>0</td><td>Number of exchange connections with other phases</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristics.BaseClasses&hellip;.</td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Mobility</a></td><td>mu</td><td>Data.mu(T, v)</td><td>Mobility [N.T/M]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>nu</td><td>Data.nu(T, v)</td><td>Thermal independity [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.DiffusivityMassSpecific">DiffusivityMassSpecific</a></td><td>zeta</td><td>Data.zeta(T, v)</td><td>** [L2.M/(N.T)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Fluidity</a></td><td>eta</td><td>Data.eta(T, v)</td><td>Fluidity [L.T/M]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>theta</td><td>Data.theta(T, v)</td><td>Thermal resistivity [L.T/N]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Independence factors</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k_intra_Phi[n_intra, n_trans]</td><td>ones(n_intra, n_trans)</td><td>For translational exchange among species within the phase [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k_intra_Q[n_intra]</td><td>ones(n_intra)</td><td>For thermal exchange among species within the phase [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T.start</td><td>T_IC</td><td>Temperature [L2.M/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi.start[n_trans]</td><td>0</td><td>Velocity [L/T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Chemical parameters</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>tauprime[n_chem]</td><td>zeros(n_chem)</td><td>Specific exchange currents [T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>kL[:]</td><td>L[cartTrans]</td><td>Effective transport length [L]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.Init">Init</a></td><td>initMaterial</td><td>Init.pressure</td><td>Method of initializing the material state</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.Init">Init</a></td><td>initEnergy</td><td>Init.temperature</td><td>Method of initializing the thermal state</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial amount of material [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Density</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial density [N/L3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume [L3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure [M/(L.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature [L2.M/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy [L2.M/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>g_IC</td><td>&nbsp;</td><td>Initial Gibbs potential [L2.M/(N.T2)]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Integer</td><td>n_trans</td><td>1</td><td>Number of transport axes</td></tr>
<tr><td>Integer</td><td>n_chem</td><td>0</td><td>Number of reaction and phase change processes</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Formulation of the conservation equations</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsThermo">ConsThermo</a></td><td>consMaterial</td><td>ConsThermo.dynamic</td><td>Material</td></tr>
<tr><td>Boolean</td><td>consRot</td><td>false</td><td>Conserve rotational momentum</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a></td><td>consTransX</td><td>ConsTrans.dynamic</td><td>X-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a></td><td>consTransY</td><td>ConsTrans.dynamic</td><td>Y-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a></td><td>consTransZ</td><td>ConsTrans.dynamic</td><td>Z-axis translational momentum</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsThermo">ConsThermo</a></td><td>consEnergy</td><td>ConsThermo.dynamic</td><td>Energy</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes with upstream discretization</td></tr>
<tr><td>Boolean</td><td>upstreamX</td><td>true</td><td>X</td></tr>
<tr><td>Boolean</td><td>upstreamY</td><td>true</td><td>Y</td></tr>
<tr><td>Boolean</td><td>upstreamZ</td><td>true</td><td>Z</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Flow conditions</td></tr>
<tr><td>Boolean</td><td>approxVelocity</td><td>true</td><td>Calculate normal boundary velocities assuming uniform density</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Phi[Axis]</td><td>{4,4,4}</td><td>Translational Nusselt numbers [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>Nu_Q</td><td>1</td><td>Thermal Nusselt number [1]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Advanced</b></td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N0</td><td>0</td><td>Nominal amount of material to prevent depletion [N]</td></tr>
</table>
<p>

<h3>Connectors</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Intra">Intra</a></td><td>intra[n_intra]</td><td>Connectors to exchange translational momentum and energy within the phase</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inter">Inter</a></td><td>inter[n_inter]</td><td>Connectors to exchange translational momentum and energy with all other species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Dalton">Dalton</a></td><td>dalton</td><td>Connector for additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Boundary">Boundary</a></td><td>boundaries[n_trans, Side]</td><td>Connectors for transport</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Chemical</a></td><td>chemical[n_chem]</td><td>Connector for reactions and phase change</td></tr>
</table>

<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> Fluid <font color="darkgreen">&quot;Base model for a fluid species&quot;</font>

  <font color="blue">import </font><a href="FCSys_Utilities_Coordinates.html#FCSys.Utilities.Coordinates.after">FCSys.Utilities.Coordinates.after</a>;
  <font color="blue">import </font><a href="FCSys_Utilities_Coordinates.html#FCSys.Utilities.Coordinates.before">FCSys.Utilities.Coordinates.before</a>;
  <font color="blue">import </font><a href="FCSys_Utilities_Coordinates.html#FCSys.Utilities.Coordinates.cartWrap">FCSys.Utilities.Coordinates.cartWrap</a>;
  <font color="blue">import </font><a href="FCSys_Utilities.html#FCSys.Utilities.Delta">FCSys.Utilities.Delta</a>;
  <font color="blue">import </font><a href="FCSys_Utilities.html#FCSys.Utilities.Sigma">FCSys.Utilities.Sigma</a>;
  <font color="blue">import </font><a href="FCSys_Utilities.html#FCSys.Utilities.inSign">FCSys.Utilities.inSign</a>;
  <font color="blue">import </font><a href="FCSys_Utilities.html#FCSys.Utilities.selectBooleans">FCSys.Utilities.selectBooleans</a>;
  <font color="blue">import </font><a href="FCSys_Utilities.html#FCSys.Utilities.selectIntegers">FCSys.Utilities.selectIntegers</a>;
  <font color="blue">import </font>assert = <a href="FCSys_Utilities.html#FCSys.Utilities.assertEval">FCSys.Utilities.assertEval</a>;

  <font color="darkgreen">// Initialization parameters</font>
  <font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.Init">Init</a> initMaterial=Init.pressure <font color="darkgreen">
    &quot;Method of initializing the material state&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.Init">Init</a> initEnergy=Init.temperature <font color="darkgreen">
    &quot;Method of initializing the thermal state&quot;</font>;
  <font color="darkgreen">// Note:  The extension is after these parameters so that they appear first</font>
  <font color="darkgreen">// in the parameter dialog.</font>
  <font color="blue">extends </font><a href="FCSys_Species.html#FCSys.Species.Species">Species</a>(N(stateSelect=<font color="blue">if </font>consMaterial == ConsThermo.dynamic<font color="blue"> then </font>
          StateSelect.always<font color="blue"> else </font>StateSelect.prefer),T(<font color="blue">final </font>fixed=false));
  <font color="darkgreen">// Note:  StateSelect.always isn&#39;t ideal, but it&#39;s necessary to avoid</font>
  <font color="darkgreen">// dynamic state selection in Dymola 2014.  In some cases it isn&#39;t</font>
  <font color="darkgreen">// appropriate (e.g., an incompressible liquid that fills the entire</font>
  <font color="darkgreen">// subregion), and in those cases it can be modified at instantiation.</font>

  <font color="darkgreen">// Material properties</font>
  <font color="blue">parameter </font>Integer n_chem=0 <font color="darkgreen">&quot;Number of reaction and phase change processes&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.DiffusivityMassSpecific">Q.DiffusivityMassSpecific</a> zeta(nominal=1e-3*U.N/U.A) = <font color="red">Data.zeta</font>(T, v) <font color="darkgreen">&quot;**&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Fluidity">Q.Fluidity</a> eta(nominal=1e5/(U.Pa*U.s)) = <font color="red">Data.eta</font>(T, v) <font color="darkgreen">&quot;Fluidity&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">Q.ResistivityThermal</a> theta(nominal=10*U.m*U.K/U.W) = <font color="red">Data.theta</font>(T, v) <font color="darkgreen">
    &quot;Thermal resistivity&quot;</font>;

  <font color="darkgreen">// Chemical parameters</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tauprime[n_chem](<font color="blue">each </font>nominal=U.ms) = <font color="red">zeros</font>(n_chem) <font color="darkgreen">
    &quot;Specific exchange currents&quot;</font>;

  <font color="darkgreen">// Geometry</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> kL[:]=L[cartTrans] <font color="darkgreen">&quot;Effective transport length&quot;</font>;
  <font color="darkgreen">// Note:  The size is n_trans, but it isn&#39;t specified here to</font>
  <font color="darkgreen">// prevent a warning in Dymola 2014.</font>

  <font color="darkgreen">// Assumptions</font>
  <font color="darkgreen">// -----------</font>
  <font color="darkgreen">// Dynamics</font>
  <font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsThermo">ConsThermo</a> consMaterial=ConsThermo.dynamic <font color="darkgreen">&quot;Material&quot;</font>;
  <font color="blue">parameter </font>Boolean consRot=false <font color="darkgreen">&quot;Conserve rotational momentum&quot;</font>;

  <font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a> consTransX=ConsTrans.dynamic <font color="darkgreen">
    &quot;X-axis translational momentum&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a> consTransY=ConsTrans.dynamic <font color="darkgreen">
    &quot;Y-axis translational momentum&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a> consTransZ=ConsTrans.dynamic <font color="darkgreen">
    &quot;Z-axis translational momentum&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsThermo">ConsThermo</a> consEnergy=ConsThermo.dynamic <font color="darkgreen">&quot;Energy&quot;</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Upstream discretization</font>
  <font color="blue">parameter </font>Boolean upstreamX=true <font color="darkgreen">&quot;X&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamY=true <font color="darkgreen">&quot;Y&quot;</font>;
  <font color="blue">parameter </font>Boolean upstreamZ=true <font color="darkgreen">&quot;Z&quot;</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Flow conditions</font>
  <font color="blue">parameter </font>Boolean approxVelocity=true <font color="darkgreen">
    &quot;Calculate normal boundary velocities assuming uniform density&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> Nu_Phi[Axis]={4,4,4} <font color="darkgreen">
    &quot;Translational Nusselt numbers&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> Nu_Q=1 <font color="darkgreen">&quot;Thermal Nusselt number&quot;</font>;

  <font color="darkgreen">// Advanced parameters</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N0=0 <font color="darkgreen">&quot;Nominal amount of material to prevent depletion&quot;</font>;

  <font color="darkgreen">// Aliases (for common terms)</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Current">Q.Current</a> I[n_trans](
    <font color="blue">each </font>nominal=U.A,
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=0) <font color="darkgreen">&quot;Current&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_boundaries[n_trans, Side](
    <font color="blue">each </font>nominal=100*U.cm/U.s,
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=0) <font color="darkgreen">&quot;Normal velocities at the boundaries&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f[n_trans](
    <font color="blue">each </font>nominal=U.N,
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=0) <font color="darkgreen">&quot;Total normal translational force on pairs of boundaries&quot;</font>;
  <font color="darkgreen">// This (f) includes the body, shear, and exchange forces due to</font>
  <font color="darkgreen">// intermolecular drag and transfer during chemical reactions and phase</font>
  <font color="darkgreen">// change.  It excludes the thermodynamic, dynamic, and  nonequilibrium</font>
  <font color="darkgreen">// compressive forces.  It also excludes transient effects since</font>
  <font color="darkgreen">// translational momentum is stored at the boundaries.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> minusDeltaf[n_trans](
    <font color="blue">each </font>nominal=U.N,
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=0) <font color="darkgreen">&quot;Dynamic and nonequilibrium compression forces&quot;</font>;

  <font color="darkgreen">// Auxiliary variables (for analysis)</font>
  <font color="darkgreen">// ----------------------------------</font>
  <font color="darkgreen">// Misc. conditions</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Q.Density</a> rho_boundaries[n_trans, Side](<font color="blue">each </font>stateSelect=StateSelect.never)
     = <font color="red">fill</font>(
    1,
    n_trans,
    2) ./ <font color="red">Data.v_Tp</font>(boundaries.T, boundaries.p) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Densities at the boundaries&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">Q.VolumeRate</a> Vdot_boundaries[n_trans, Side](<font color="blue">each </font>stateSelect=
        StateSelect.never) = boundaries.Ndot ./ rho_boundaries <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Volume flow rates into the boundaries&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> q[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = (
    Data.m/2)*phi .* I ./ Aprime <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Dynamic pressure&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi_chemical[n_chem, n_trans](<font color="blue">each </font>stateSelect=StateSelect.never)
     = <font color="red">actualStream</font>(chemical.phi) <font color="blue">if </font>environment.analysis<font color="blue"> and </font>n_chem &gt; 0 <font color="darkgreen">
    &quot;Velocity of the chemical streams&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PotentialAbsolute">Q.PotentialAbsolute</a> sT_chemical[n_chem](<font color="blue">each </font>stateSelect=StateSelect.never)
     = <font color="red">actualStream</font>(chemical.sT) <font color="blue">if </font>environment.analysis<font color="blue"> and </font>n_chem &gt; 0 <font color="darkgreen">
    &quot;Specific entropy-temperature product of the chemical streams&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Temperature">Q.Temperature</a> DeltaT[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    Delta</font>(boundaries.T) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Differences in temperatures across the boundaries&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Pressure">Q.Pressure</a> Deltap[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">Delta</font>
    (boundaries.p) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Differences in pressures across the boundaries&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Hprimedot[n_trans, Side](<font color="blue">each </font>stateSelect=StateSelect.never)
     = (<font color="red">Data.h</font>(boundaries.T, boundaries.p) + Data.m*phi_boundaries .^ 2/2) .*
    boundaries.Ndot <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Flow rates of enthalpy + kinetic energy into the boundaries&quot;</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Potentials</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> g_boundaries[n_trans, Side](<font color="blue">each </font>stateSelect=StateSelect.never)
     = <font color="red">Data.g</font>(boundaries.T, boundaries.p) <font color="blue">if </font>environment.analysis<font color="blue"> and </font><font color="blue">not </font>Data.isCompressible
    <font color="darkgreen">&quot;Gibbs potentials at the boundaries&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> Deltag[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    Delta</font>(g_boundaries) <font color="blue">if </font>environment.analysis<font color="blue"> and </font><font color="blue">not </font>Data.isCompressible <font color="darkgreen">
    &quot;Differences in Gibbs potentials across the boundaries&quot;</font>;
  <font color="darkgreen">// Note:  If a boundary is left unconnnected, then it&#39;s possible that its</font>
  <font color="darkgreen">// pressure may become negative.  If the equation of state has an ideal-gas</font>
  <font color="darkgreen">// term, then the Gibbs energy will involve a logarithm of pressure.</font>
  <font color="darkgreen">// Therefore, to prevent errors, these variables are included only for</font>
  <font color="darkgreen">// incompressible species.</font>
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Time constants</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_NT[n_trans](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = <font color="red">fill</font>(zeta*beta*N, n_trans) ./ (2*Aprime) <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Time constants for material transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_PhiT[n_trans](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = M*eta*kL ./ (2*Nu_Phi[cartTrans] .* Aprime) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">
    &quot;Time constants for transverse translational transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_QT[n_trans](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = (N*c_v*theta/(2*Nu_Q))*kL ./ Aprime <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Time constants for thermal transport&quot;</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Peclet numbers</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_N[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = tau_NT .*
    I/N <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Material Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_Phi[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) =
    tau_PhiT .* I/N <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Translational Peclet numbers&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Number">Q.Number</a> Pe_Q[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = tau_QT .*
    I/N <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Thermal Peclet numbers&quot;</font>;
  <font color="darkgreen">// Note:  These Peclet numbers are calculated at the center of the</font>
  <font color="darkgreen">// subregion (for simplicity), but the Peclet numbers used in the transport</font>
  <font color="darkgreen">// equations are at each boundary.</font>
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Bulk flow rates</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> mphiI[n_trans, n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    outerProduct</font>(I, Data.m*phi) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Bulk rate of translational advection (1st index: transport axis, 2nd index: translational component)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.VolumeRate">Q.VolumeRate</a> Vdot[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = v*I <font color="blue">
    if </font>environment.analysis <font color="darkgreen">&quot;Bulk volumetric flow rate&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> hI[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = h*I <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Bulk enthalpy flow rate&quot;</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Translational momentum balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> Ma[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = M*(<font color="red">der</font>(phi)/
    U.s + environment.a[cartTrans]) + N*Data.z*environment.E[cartTrans] <font color="blue">if </font>
    environment.analysis <font color="darkgreen">
    &quot;Acceleration force (including acceleration due to body forces)&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_thermo[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = -<font color="red">Delta</font>
    (boundaries.p) .* Aprime <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Thermodynamic force&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_AE[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = Data.m*<font color="red">sum</font>
    ((<font color="red">actualStream</font>(chemical[i].phi) - phi)*chemical[i].Ndot <font color="blue">for </font>i<font color="blue"> in </font>1:n_chem) <font color="blue">
    if </font>environment.analysis <font color="darkgreen">&quot;Acceleration force due to advective exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_AT[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = {<font color="red">sum</font>(((<font color="blue">if </font>
    i == j<font color="blue"> then </font>phi_boundaries[j, :]<font color="blue"> else </font>boundaries[j, :].phi[<font color="red">cartWrap</font>(
    cartTrans[i] - cartTrans[j])]) - {phi[i],phi[i]})*boundaries[j, :].Ndot*
    Data.m <font color="blue">for </font>j<font color="blue"> in </font>1:n_trans) <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans} <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Acceleration force due to advective transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_DT[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = {<font color="red">sum</font>(<font color="red">sum</font>(<font color="blue">
    if </font>i == j<font color="blue"> then </font>{0,0}<font color="blue"> else </font>boundaries[j, :].mPhidot[<font color="red">cartWrap</font>(cartTrans[i] -
    cartTrans[j])]) <font color="blue">for </font>j<font color="blue"> in </font>1:n_trans) <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans} <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Shear force from other subregions (diffusive transport)&quot;</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Energy balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Ndere(stateSelect=StateSelect.never) = (N*T*<font color="red">der</font>(<font color="red">Data.s</font>(T, p)) +
    M*phi*<font color="red">der</font>(phi))/U.s <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of energy storage (internal and kinetic) and boundary work at constant mass&quot;</font>;
  <font color="darkgreen">// Note that T*der(s) = der(u) + p*der(v).</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Edot_AE(stateSelect=StateSelect.never) = <font color="red">sum</font>((chemical[i].g + <font color="red">
    actualStream</font>(chemical[i].sT) - h + (<font color="red">actualStream</font>(chemical[i].phi)*<font color="red">
    actualStream</font>(chemical[i].phi) - phi*phi)*Data.m/2)*chemical[i].Ndot <font color="blue">for </font>i<font color="blue">
     in </font>1:n_chem) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Relative rate of energy (internal, flow, and kinetic) due to reactions and phase change&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Edot_AT(stateSelect=StateSelect.never) = <font color="red">sum</font>((<font color="red">Data.h</font>(
    boundaries[i, :].T, boundaries[i, :].p) - {h,h} + (phi_boundaries[i, :] .^ 2
     + <font color="red">sum</font>(boundaries[i, :].phi[orient] .^ 2 <font color="blue">for </font>orient<font color="blue"> in </font>Orient) - <font color="red">fill</font>(phi*
    phi, 2))*(Data.m/2))*boundaries[i, :].Ndot <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans) <font color="blue">if </font>
    environment.analysis <font color="darkgreen">
    &quot;Relative rate of energy (internal, flow, and kinetic) due to advective transport&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Edot_DT(stateSelect=StateSelect.never) = <font color="red">sum</font>(<font color="red">sum</font>(boundaries[i,
    :].phi[orient]*boundaries[i, :].mPhidot[orient] <font color="blue">for </font>orient<font color="blue"> in </font>Orient) <font color="blue">for </font>i<font color="blue">
     in </font>1:n_trans) + <font color="red">sum</font>(boundaries.Qdot) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Rate of diffusion of energy from other subregions&quot;</font>;
  <font color="darkgreen">// Note:  The structure of the problem shouldn&#39;t change if these</font>
  <font color="darkgreen">// auxiliary variables are included (hence, StateSelect.never).</font>

  <a href="FCSys_Connectors.html#FCSys.Connectors.Boundary">Connectors.Boundary</a> boundaries[n_trans, Side](
    <font color="blue">each </font>p(start=p_IC),
    <font color="blue">each </font>T(start=T_IC),
    Ndot(<font color="blue">each </font>start=0, <font color="blue">each </font>stateSelect=StateSelect.never)) <font color="darkgreen">
    &quot;Connectors for transport&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Chemical">Connectors.Chemical</a> chemical[n_chem](
    <font color="blue">each </font><font color="blue">final </font>n_trans=n_trans,
    g(<font color="blue">each </font>start=g_IC, <font color="blue">each </font><font color="blue">final </font>fixed=false),
    sT(<font color="blue">each </font>start=h_IC - g_IC, <font color="blue">each </font><font color="blue">final </font>fixed=false)) <font color="darkgreen">
    &quot;Connector for reactions and phase change&quot;</font>;

  <font color="darkgreen">// Geometric parameters</font>

<font color="blue">protected </font>
  <font color="blue">outer </font><a href="FCSys_Quantities.html#FCSys.Quantities.Area">Q.Area</a> Aprime[n_trans] <font color="darkgreen">&quot;Effective cross-sectional area&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Boolean inclRot[3] <font color="darkgreen">
    &quot;true, if each axis of rotation has all its tangential boundaries included&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Boolean inclTrans[3] <font color="darkgreen">
    &quot;true, if each transport axis is included&quot;</font>;
  <font color="darkgreen">// Note:  The size of inclRot and inclTrans is also Axis, but it can&#39;t be</font>
  <font color="darkgreen">// specified here due to an error in Dymola 2014.</font>
  <font color="blue">outer </font><font color="blue">parameter </font>Integer cartRot[:] <font color="darkgreen">
    &quot;Cartesian-axis indices of the components of rotational momentum&quot;</font>;
  <font color="darkgreen">// Note:  The size of cartRot is n_trans, but it can&#39;t be</font>
  <font color="darkgreen">// specified here due to an error in Dymola 2014.</font>
  <font color="blue">outer </font><font color="blue">parameter </font>Integer transCart[3] <font color="darkgreen">
    &quot;Boundary-pair indices of the Cartesian axes&quot;</font>;
  <font color="darkgreen">// Note:  The size is also Axis, but it can&#39;t be specified here due</font>
  <font color="darkgreen">// to an error in Dymola 2014.</font>
  <font color="blue">final </font><font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsTrans">ConsTrans</a> consTrans[n_trans]=<font color="red">selectIntegers</font>({consTransX,
      consTransY,consTransZ}, cartTrans) <font color="darkgreen">
    &quot;Formulation of the translational conservation equations for the transport axes&quot;</font>;
  <font color="blue">final </font><font color="blue">parameter </font>Boolean upstream[n_trans]=<font color="red">selectBooleans</font>({upstreamX,upstreamY,
      upstreamZ}, cartTrans) <font color="darkgreen">
    &quot;true, if each transport axis uses upstream discretization&quot;</font>;

  <font color="darkgreen">// Additional aliases (for common terms)</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> mPhidot_boundaries[n_trans, Side, Orient](<font color="blue">each </font>nominal=U.N, <font color="blue">each </font>
      stateSelect=StateSelect.never) <font color="darkgreen">&quot;Directly-calculated shear forces&quot;</font>;

  <font color="blue">outer </font><a href="FCSys_Conditions.html#FCSys.Conditions.Environment">Conditions.Environment</a> environment <font color="darkgreen">&quot;Environmental conditions&quot;</font>;

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="darkgreen">// Check the initial conditions.</font>
  <font color="red">assert</font>(V &gt;= 0, &quot;The volume of &quot; + <font color="red">getInstanceName</font>() + &quot; is negative.
Check that the volumes of the other phases are set properly.&quot;);
  <font color="red">assert</font>(initMaterial &lt;&gt; initEnergy<font color="blue"> or </font>initMaterial == Init.none<font color="blue"> or </font>
    consMaterial == ConsThermo.steady<font color="blue"> or </font>consEnergy == ConsThermo.steady, &quot;The initialization methods for material and energy must be different (unless none).&quot;);

  <font color="darkgreen">// Material</font>
  <font color="blue">if </font>consMaterial == ConsThermo.IC<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected since the state is prescribed.</font>
    <font color="red">assert</font>(initMaterial &lt;&gt; Init.none, &quot;The material state of &quot; + <font color="red">
      getInstanceName</font>() + &quot; is prescribed, yet its condition is not defined.
Choose any condition besides none.&quot;);
  <font color="blue">elseif </font>consMaterial == ConsThermo.dynamic<font color="blue"> then</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initMaterial == Init.amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMaterial == Init.amountSS<font color="blue"> then</font>
      <font color="red">der</font>(N) = 0;
    <font color="blue">elseif </font>initMaterial == Init.density<font color="blue"> then</font>
      <font color="red">assert</font>(Data.isCompressible<font color="blue"> or </font>Data.hasThermalExpansion, <font color="red">getInstanceName</font>() + &quot; is isochoric, yet its material initial condition is based on density.&quot;);
      1/v = rho_IC;
    <font color="blue">elseif </font>initMaterial == Init.densitySS<font color="blue"> then</font>
      <font color="red">assert</font>(Data.isCompressible<font color="blue"> or </font>Data.hasThermalExpansion, <font color="red">getInstanceName</font>() + &quot; is isochoric, yet its material initial condition is based on density.&quot;);
      <font color="red">der</font>(1/v) = 0;
    <font color="blue">elseif </font>initMaterial == Init.volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMaterial == Init.volumeSS<font color="blue"> then</font>
      <font color="red">der</font>(V) = 0;
    <font color="blue">elseif </font>initMaterial == Init.pressure<font color="blue"> then</font>
      p = p_IC;
      <font color="red">assert</font>(Data.isCompressible, <font color="red">getInstanceName</font>() + &quot; is incompressible, yet its material initial condition is based on pressure.&quot;);
    <font color="blue">elseif </font>initMaterial == Init.pressureSS<font color="blue"> then</font>
      <font color="red">der</font>(p) = 0;
      <font color="red">assert</font>(Data.isCompressible, <font color="red">getInstanceName</font>() + &quot; is incompressible, yet its material initial condition is based on pressure.&quot;);
    <font color="blue">elseif </font>initMaterial == Init.temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMaterial == Init.temperatureSS<font color="blue"> then</font>
      <font color="red">der</font>(T) = 0;
    <font color="blue">elseif </font>initMaterial == Init.specificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMaterial == Init.specificEnthalpySS<font color="blue"> then</font>
      <font color="red">der</font>(h) = 0;
    <font color="blue">elseif </font>initMaterial == Init.Gibbs<font color="blue"> then</font>
      g = g_IC;
    <font color="blue">elseif </font>initMaterial == Init.GibbsSS<font color="blue"> then</font>
      <font color="red">der</font>(g) = 0;
      <font color="darkgreen">// Else, there&#39;s no initial equation since</font>
      <font color="darkgreen">// initMaterial == Init.none or</font>
      <font color="darkgreen">// consMaterial == ConsThermo.steady.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Energy</font>
  <font color="blue">if </font>consEnergy == ConsThermo.IC<font color="blue"> then</font>
    <font color="darkgreen">// Ensure that a condition is selected since the state is prescribed.</font>
    <font color="red">assert</font>(initEnergy &lt;&gt; Init.none, &quot;The energy state of &quot; + <font color="red">getInstanceName</font>() + &quot; is prescribed, yet its condition is not defined.
Choose any condition besides none.&quot;);
  <font color="blue">elseif </font>consEnergy == ConsThermo.dynamic<font color="blue"> then</font>
    <font color="darkgreen">// Initialize since there&#39;s a time-varying state.</font>
    <font color="blue">if </font>initEnergy == Init.amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initEnergy == Init.amountSS<font color="blue"> then</font>
      <font color="red">der</font>(N) = 0;
    <font color="blue">elseif </font>initEnergy == Init.density<font color="blue"> then</font>
      1/v = rho_IC;
      <font color="red">assert</font>(Data.isCompressible<font color="blue"> or </font>Data.hasThermalExpansion, <font color="red">getInstanceName</font>() + &quot; is isochoric, yet its thermal initial condition is based on density.&quot;);
    <font color="blue">elseif </font>initEnergy == Init.densitySS<font color="blue"> then</font>
      <font color="red">der</font>(1/v) = 0;
      <font color="red">assert</font>(Data.isCompressible<font color="blue"> or </font>Data.hasThermalExpansion, <font color="red">getInstanceName</font>() + &quot; is isochoric, yet its thermal initial condition is based on density.&quot;);
    <font color="blue">elseif </font>initEnergy == Init.volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initEnergy == Init.volumeSS<font color="blue"> then</font>
      <font color="red">der</font>(V) = 0;
    <font color="blue">elseif </font>initEnergy == Init.pressure<font color="blue"> then</font>
      p = p_IC;
      <font color="red">assert</font>(Data.isCompressible, <font color="red">getInstanceName</font>() + &quot; is incompressible, yet its thermal initial condition is based on pressure.&quot;);
    <font color="blue">elseif </font>initEnergy == Init.pressureSS<font color="blue"> then</font>
      <font color="red">der</font>(p) = 0;
      <font color="red">assert</font>(Data.isCompressible, <font color="red">getInstanceName</font>() + &quot; is incompressible, yet its thermal initial condition is based on pressure.&quot;);
    <font color="blue">elseif </font>initEnergy == Init.temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initEnergy == Init.temperatureSS<font color="blue"> then</font>
      <font color="red">der</font>(T) = 0;
    <font color="blue">elseif </font>initEnergy == Init.specificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initEnergy == Init.specificEnthalpySS<font color="blue"> then</font>
      <font color="red">der</font>(h) = 0;
    <font color="blue">elseif </font>initEnergy == Init.Gibbs<font color="blue"> then</font>
      g = g_IC;
    <font color="blue">elseif </font>initEnergy == Init.GibbsSS<font color="blue"> then</font>
      <font color="red">der</font>(g) = 0;
      <font color="darkgreen">// Else, there&#39;s no initial equation since</font>
      <font color="darkgreen">// initEnergy == Init.none or</font>
      <font color="darkgreen">// consEnergy == ConsThermo.steady.</font>
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

<font color="blue">equation </font>
  <font color="darkgreen">// Aliases (only to clarify and simplify other equations)</font>
  v*I = Aprime .* phi <font color="darkgreen">&quot;Current vs. velocity&quot;</font>;
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans<font color="blue"> loop</font>
    <font color="blue">for </font>side<font color="blue"> in </font>Side<font color="blue"> loop</font>
      (<font color="blue">if </font>approxVelocity<font color="blue"> then </font>v<font color="blue"> else </font><font color="red">Data.v_Tp</font>(boundaries[i, side].T,
        boundaries[i, side].p))*boundaries[i, side].Ndot = <font color="red">inSign</font>(side)*Aprime[
        i]*phi_boundaries[i, side] <font color="darkgreen">&quot;Current vs. velocity at the boundaries&quot;</font>;
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;
  minusDeltaf = Data.m*phi .* I;

  <font color="darkgreen">// Assumptions</font>
  2*I = -<font color="red">Delta</font>(boundaries.Ndot) <font color="darkgreen">&quot;Linear current profile (assumption #1)&quot;</font>;

  <font color="darkgreen">// Equation of state</font>
  <font color="blue">if </font>Data.isCompressible<font color="blue"> then</font>
    p = <font color="red">Data.p_Tv</font>(T, v) + zeta*<font color="red">der</font>(1/v)/U.s;
  <font color="blue">else</font>
    v = <font color="red">Data.v_Tp</font>(T, p - zeta*<font color="red">der</font>(1/v)/U.s);
  <font color="blue">end if</font>;

  <font color="darkgreen">// Properties upon outflow due to reaction and phase change</font>
  chemical.phi = <font color="red">fill</font>(phi, n_chem);
  chemical.sT = <font color="red">fill</font>(h - g, n_chem);

  <font color="darkgreen">// Material exchange</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_chem<font color="blue"> loop</font>
    <font color="blue">if </font>tauprime[i] &gt; Modelica.Constants.small<font color="blue"> then</font>
      tauprime[i]*(chemical[i].Ndot - 0.001*<font color="red">der</font>(chemical[i].Ndot)/U.s) = (N +
        N0)*<font color="red">exp</font>((chemical[i].g - g)/T) - N;
    <font color="blue">else</font>
      chemical[i].g = g;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Transport</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans<font color="blue"> loop</font>
    <font color="blue">for </font>side<font color="blue"> in </font>Side<font color="blue"> loop</font>
      <font color="darkgreen">// Material</font>
      (<font color="blue">if </font>consTrans[i] == ConsTrans.dynamic<font color="blue"> then </font>kL[i]*Data.m*<font color="red">der</font>(boundaries[i,
        side].Ndot)/U.s<font color="blue"> else </font>0) = (Aprime[i]*(boundaries[i, side].p - p) + <font color="red">
        inSign</font>(side)*Data.m*phi_boundaries[i, side]*boundaries[i, side].Ndot -
        minusDeltaf[i])*(<font color="blue">if </font>upstream[i]<font color="blue"> then </font>1 + <font color="red">exp</font>(-zeta*<font color="red">Data.beta</font>(T, p)*
        boundaries[i, side].Ndot/(2*Aprime[i]))<font color="blue"> else </font>2) + <font color="red">inSign</font>(side)*f[i];

      <font color="darkgreen">// Translational momentum</font>
      kL[i]*eta*mPhidot_boundaries[i, side, Orient.after] = Aprime[i]*Nu_Phi[<font color="red">
        after</font>(cartTrans[i])]*(boundaries[i, side].phi[Orient.after] - (<font color="blue">if </font>
        inclTrans[<font color="red">after</font>(cartTrans[i])]<font color="blue"> then </font>phi[transCart[<font color="red">after</font>(cartTrans[i])]]<font color="blue">
         else </font>0))*(<font color="blue">if </font>upstream[i]<font color="blue"> then </font>1 + <font color="red">exp</font>(-kL[i]*eta*Data.m*boundaries[i,
        side].Ndot/(2*Aprime[i]*Nu_Phi[<font color="red">after</font>(cartTrans[i])]))<font color="blue"> else </font>2) <font color="darkgreen">
        &quot;1st transverse&quot;</font>;
      kL[i]*eta*mPhidot_boundaries[i, side, Orient.before] = Aprime[i]*Nu_Phi[<font color="red">
        before</font>(cartTrans[i])]*(boundaries[i, side].phi[Orient.before] - (<font color="blue">if </font>
        inclTrans[<font color="red">before</font>(cartTrans[i])]<font color="blue"> then </font>phi[transCart[<font color="red">before</font>(cartTrans[i])]]<font color="blue">
         else </font>0))*(<font color="blue">if </font>upstream[i]<font color="blue"> then </font>1 + <font color="red">exp</font>(-kL[i]*eta*Data.m*boundaries[i,
        side].Ndot/(2*Aprime[i]*Nu_Phi[<font color="red">before</font>(cartTrans[i])]))<font color="blue"> else </font>2) <font color="darkgreen">
        &quot;2nd transverse&quot;</font>;

      <font color="darkgreen">// Thermal energy</font>
      kL[i]*theta*boundaries[i, side].Qdot = Aprime[i]*Nu_Q*(boundaries[i, side].T
         - T)*(<font color="blue">if </font>upstream[i]<font color="blue"> then </font>1 + <font color="red">exp</font>(-kL[i]*theta*<font color="red">Data.c_v</font>(T, p)*
        boundaries[i, side].Ndot/(2*Aprime[i]*Nu_Q))<font color="blue"> else </font>2);
    <font color="blue">end for</font>;

    <font color="darkgreen">// Direct mapping of shear forces (calculated above)</font>
    <font color="blue">if </font><font color="blue">not </font>(consRot<font color="blue"> and </font>inclRot[<font color="red">before</font>(cartTrans[i])])<font color="blue"> then</font>
      boundaries[i, :].mPhidot[Orient.after] = mPhidot_boundaries[i, :, Orient.after];
      <font color="darkgreen">// Else, the force must be mapped for zero torque (below).</font>
    <font color="blue">end if</font>;
    <font color="blue">if </font><font color="blue">not </font>(consRot<font color="blue"> and </font>inclRot[<font color="red">after</font>(cartTrans[i])])<font color="blue"> then</font>
      boundaries[i, :].mPhidot[Orient.before] = mPhidot_boundaries[i, :, Orient.before];
      <font color="darkgreen">// Else, the force must be mapped for zero torque (below).</font>
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Zero-torque mapping of shear forces</font>
  <font color="blue">if </font>consRot<font color="blue"> then</font>
    <font color="blue">for </font>axis<font color="blue"> in </font>cartRot<font color="blue"> loop</font>
      4*<font color="red">cat</font>(
        1,
        boundaries[transCart[<font color="red">after</font>(axis)], :].mPhidot[Orient.after],
        boundaries[transCart[<font color="red">before</font>(axis)], :].mPhidot[Orient.before]) = {{3,1,
        L[<font color="red">before</font>(axis)]/L[<font color="red">after</font>(axis)],-L[<font color="red">before</font>(axis)]/L[<font color="red">after</font>(axis)]},{1,3,-L[<font color="red">
        before</font>(axis)]/L[<font color="red">after</font>(axis)],L[<font color="red">before</font>(axis)]/L[<font color="red">after</font>(axis)]},{L[<font color="red">after</font>(
        axis)]/L[<font color="red">before</font>(axis)],-L[<font color="red">after</font>(axis)]/L[<font color="red">before</font>(axis)],3,1},{-L[<font color="red">after</font>(
        axis)]/L[<font color="red">before</font>(axis)],L[<font color="red">after</font>(axis)]/L[<font color="red">before</font>(axis)],1,3}}*<font color="red">cat</font>(
        1,
        mPhidot_boundaries[transCart[<font color="red">after</font>(axis)], :, Orient.after],
        mPhidot_boundaries[transCart[<font color="red">before</font>(axis)], :, Orient.before]);
    <font color="blue">end for</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Material dynamics</font>
  <font color="blue">if </font>consMaterial == ConsThermo.IC<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC forever (material not conserved).</font>
    <font color="blue">if </font>initMaterial == Init.amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initMaterial == Init.amountSS<font color="blue"> then</font>
      <font color="red">der</font>(N) = 0;
    <font color="blue">elseif </font>initMaterial == Init.density<font color="blue"> then</font>
      1/v = rho_IC;
    <font color="blue">elseif </font>initMaterial == Init.densitySS<font color="blue"> then</font>
      <font color="red">der</font>(1/v) = 0;
    <font color="blue">elseif </font>initMaterial == Init.volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initMaterial == Init.volumeSS<font color="blue"> then</font>
      <font color="red">der</font>(V) = 0;
    <font color="blue">elseif </font>initMaterial == Init.pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initMaterial == Init.pressureSS<font color="blue"> then</font>
      <font color="red">der</font>(p) = 0;
    <font color="blue">elseif </font>initMaterial == Init.temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initMaterial == Init.temperatureSS<font color="blue"> then</font>
      <font color="red">der</font>(T) = 0;
    <font color="blue">elseif </font>initMaterial == Init.specificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initMaterial == Init.specificEnthalpySS<font color="blue"> then</font>
      <font color="red">der</font>(h) = 0;
    <font color="blue">elseif </font>initMaterial == Init.Gibbs<font color="blue"> then</font>
      g = g_IC;
    <font color="blue">else</font>
      <font color="darkgreen">// if initMaterial == Init.GibbsSS then</font>
      <font color="red">der</font>(g) = 0;
      <font color="darkgreen">// Note:  initMaterial == Init.none can&#39;t occur due to an assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    (<font color="blue">if </font>consMaterial == ConsThermo.dynamic<font color="blue"> then </font><font color="red">der</font>(N)/U.s<font color="blue"> else </font>0) = <font color="red">sum</font>(
      chemical.Ndot) + <font color="red">sum</font>(boundaries.Ndot) <font color="darkgreen">&quot;Material conservation&quot;</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Conservation of translational momentum</font>
  f + M*environment.a[cartTrans] + Data.z*N*environment.E[cartTrans] = Data.m*<font color="red">
    sum</font>(<font color="red">actualStream</font>(chemical[i].phi)*chemical[i].Ndot <font color="blue">for </font>i<font color="blue"> in </font>1:n_chem) + {<font color="red">
    sum</font>(intra[:].mPhidot[j]) + <font color="red">sum</font>(inter[:].mPhidot[j]) + <font color="red">sum</font>((<font color="blue">if </font>i == j<font color="blue"> then </font>0<font color="blue">
     else </font>boundaries[i, :].phi[<font color="red">cartWrap</font>(cartTrans[j] - cartTrans[i])]*
    boundaries[i, :].Ndot*Data.m + <font color="red">sum</font>(boundaries[i, :].mPhidot[<font color="red">cartWrap</font>(
    cartTrans[j] - cartTrans[i])])) <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans) <font color="blue">for </font>j<font color="blue"> in </font>1:n_trans};
  <font color="darkgreen">// Note:  The storage is split between the boundaries via f, so a</font>
  <font color="darkgreen">// derivative doesn&#39;t appear here (see material transport above).</font>
  <font color="darkgreen">// Note:  The explicit expansions (intra[:] and inter[:]) are necessary in</font>
  <font color="darkgreen">// Dymola 2014.</font>

  <font color="darkgreen">// Thermal dynamics</font>
  <font color="blue">if </font>consEnergy == ConsThermo.IC<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC forever (energy not conserved).</font>
    <font color="blue">if </font>initEnergy == Init.amount<font color="blue"> then</font>
      N = N_IC;
    <font color="blue">elseif </font>initEnergy == Init.amountSS<font color="blue"> then</font>
      <font color="red">der</font>(N) = 0;
    <font color="blue">elseif </font>initEnergy == Init.density<font color="blue"> then</font>
      1/v = rho_IC;
    <font color="blue">elseif </font>initEnergy == Init.densitySS<font color="blue"> then</font>
      <font color="red">der</font>(1/v) = 0;
    <font color="blue">elseif </font>initEnergy == Init.volume<font color="blue"> then</font>
      V = V_IC;
    <font color="blue">elseif </font>initEnergy == Init.volumeSS<font color="blue"> then</font>
      <font color="red">der</font>(V) = 0;
    <font color="blue">elseif </font>initEnergy == Init.pressure<font color="blue"> then</font>
      p = p_IC;
    <font color="blue">elseif </font>initEnergy == Init.pressureSS<font color="blue"> then</font>
      <font color="red">der</font>(p) = 0;
    <font color="blue">elseif </font>initEnergy == Init.temperature<font color="blue"> then</font>
      T = T_IC;
    <font color="blue">elseif </font>initEnergy == Init.temperatureSS<font color="blue"> then</font>
      <font color="red">der</font>(T) = 0;
    <font color="blue">elseif </font>initEnergy == Init.specificEnthalpy<font color="blue"> then</font>
      h = h_IC;
    <font color="blue">elseif </font>initEnergy == Init.specificEnthalpySS<font color="blue"> then</font>
      <font color="red">der</font>(h) = 0;
    <font color="blue">elseif </font>initEnergy == Init.Gibbs<font color="blue"> then</font>
      g = g_IC;
    <font color="blue">else</font>
      <font color="darkgreen">// if initEnergy == Init.GibbsSS then</font>
      <font color="red">der</font>(g) = 0;
      <font color="darkgreen">// Note:  initEnergy == Init.none can&#39;t occur due to an assertion.</font>
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    (<font color="blue">if </font>consEnergy == ConsThermo.dynamic<font color="blue"> then </font>(N*T*<font color="red">der</font>(s) + <font color="red">der</font>(M*phi*phi)/2)/U.s<font color="blue">
       else </font>0) = <font color="red">sum</font>((chemical[i].g + <font color="red">actualStream</font>(chemical[i].sT) - h + <font color="red">
      actualStream</font>(chemical[i].phi)*<font color="red">actualStream</font>(chemical[i].phi)*Data.m/2)*
      chemical[i].Ndot <font color="blue">for </font>i<font color="blue"> in </font>1:n_chem) + <font color="red">sum</font>(intra[i].phi*intra[i].mPhidot <font color="blue">
      for </font>i<font color="blue"> in </font>1:n_intra) + <font color="red">sum</font>(inter[i].phi*inter[i].mPhidot <font color="blue">for </font>i<font color="blue"> in </font>1:
      n_inter) + <font color="red">sum</font>(intra.Qdot) + <font color="red">sum</font>(inter.Qdot) + <font color="red">sum</font>((<font color="red">Data.h</font>(boundaries[i,
      :].T, boundaries[i, :].p) - {h,h} + (phi_boundaries[i, :] .^ 2 + <font color="red">sum</font>(
      boundaries[i, :].phi[orient] .^ 2 <font color="blue">for </font>orient<font color="blue"> in </font>Orient))*(Data.m/2))*
      boundaries[i, :].Ndot + <font color="red">sum</font>(boundaries[i, :].phi[orient]*boundaries[i, :].mPhidot[
      orient] <font color="blue">for </font>orient<font color="blue"> in </font>Orient) <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans) + <font color="red">sum</font>(boundaries.Qdot) <font color="darkgreen">
      &quot;Conservation of energy&quot;</font>;
  <font color="blue">end if</font>;
<font color="blue">end </font>Fluid;
</pre>
<hr>

<h2><img src="images/FCSys.Species.SolidI.png" alt="FCSys.Species.Solid" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Species.Solid"></a><a href="FCSys_Species.html#FCSys.Species">FCSys.Species</a>.Solid</h2>
<b>Base model for an inert, stationary solid</b>
<img src="images/FCSys.Species.SolidD.png" alt="FCSys.Species.Solid">

<h3>Information</h3>

<p>Assumptions:</p><ol>
  <li>There is no material transport.</li>
  <li>Velocity is zero.</li>
  <li>There are no chemical reactions or phase change.</li>
  <li>The volume is constant&mdash;determined by &epsilon; and the total volume of the subregion.</li>
  </ol>

  <p>For more information, please see the <a href="FCSys_Species.html#FCSys.Species.Species">Species</a> model.</p>
Extends from <a href="FCSys_Species.html#FCSys.Species.Species">Species</a> (Base model for one chemical species in one phase).
<p>

<h3>Parameters</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<tr><td>Integer</td><td>n_inter</td><td>0</td><td>Number of exchange connections with other phases</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Geometry</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>epsilon</td><td>0.25</td><td>Volumetric fill fraction [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Length</a></td><td>kL[:]</td><td>L[cartTrans]</td><td>Effective transport length [L]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristics.BaseClasses&hellip;.</td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Mobility</a></td><td>mu</td><td>Data.mu(T, v)</td><td>Mobility [N.T/M]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>nu</td><td>Data.nu(T, v)</td><td>Thermal independity [T]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">ResistivityThermal</a></td><td>theta</td><td>Data.theta(T, v)</td><td>Thermal resistivity [L.T/N]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Independence factors</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k_intra_Phi[n_intra, n_trans]</td><td>ones(n_intra, n_trans)</td><td>For translational exchange among species within the phase [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k_intra_Q[n_intra]</td><td>ones(n_intra)</td><td>For thermal exchange among species within the phase [1]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Initialization</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T.start</td><td>T_IC</td><td>Temperature [L2.M/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Velocity</a></td><td>phi.start[n_trans]</td><td>0</td><td>Velocity [L/T]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Integer</td><td>n_trans</td><td>1</td><td>Number of transport axes</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Formulation of the conservation equations</td></tr>
<tr><td><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsThermo">ConsThermo</a></td><td>consEnergy</td><td>ConsThermo.dynamic</td><td>Energy</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Density</a></td><td>rho_IC</td><td>1/Data.v_Tp()</td><td>Initial density [N/L3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>epsilon*product(L)</td><td>Initial volume [L3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>environment.p</td><td>Initial pressure [M/(L.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature [L2.M/(N.T2)]</td></tr>
</table>
<p>

<h3>Connectors</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Intra">Intra</a></td><td>intra[n_intra]</td><td>Connectors to exchange translational momentum and energy within the phase</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inter">Inter</a></td><td>inter[n_inter]</td><td>Connectors to exchange translational momentum and energy with all other species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Dalton">Dalton</a></td><td>dalton</td><td>Connector for additivity of pressure</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.ThermalDiffusive">ThermalDiffusive</a></td><td>boundaries[n_trans, Side]</td><td>Connectors for transport</td></tr>
</table>

<h3>Modelica definition</h3>

<pre>
<font color="blue">model</font> Solid <font color="darkgreen">&quot;Base model for an inert, stationary solid&quot;</font>
  <font color="blue">import </font><a href="FCSys_Utilities.html#FCSys.Utilities.Delta">FCSys.Utilities.Delta</a>;

  <font color="darkgreen">// Geometry</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> epsilon=0.25 <font color="darkgreen">&quot;Volumetric fill fraction&quot;</font>;
  <font color="blue">extends </font><a href="FCSys_Species.html#FCSys.Species.Species">Species</a>(
    <font color="blue">final </font>N_IC,
    <font color="blue">final </font>V_IC=epsilon*<font color="red">product</font>(L),
    <font color="blue">final </font>rho_IC=1/<font color="red">Data.v_Tp</font>(),
    <font color="blue">final </font>p_IC=environment.p,
    <font color="blue">final </font>h_IC,
    <font color="blue">final </font>g_IC,
    T(stateSelect=<font color="blue">if </font>consEnergy == ConsThermo.dynamic<font color="blue"> then </font>StateSelect.always<font color="blue">
           else </font>StateSelect.default,fixed=consEnergy == ConsThermo.dynamic));
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> kL[:]=L[cartTrans] <font color="darkgreen">&quot;Effective transport length&quot;</font>;
  <font color="darkgreen">// Note:  The size is n_trans, but it isn&#39;t specified here to prevent a</font>
  <font color="darkgreen">// warning in Dymola 2014.</font>

  <font color="darkgreen">// Material properties</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.ResistivityThermal">Q.ResistivityThermal</a> theta(nominal=10*U.cm/U.A) = <font color="red">Data.theta</font>(T, v) <font color="darkgreen">
    &quot;Thermal resistivity&quot;</font>;

  <font color="darkgreen">// Assumptions</font>
  <font color="blue">parameter </font><a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.ConsThermo">ConsThermo</a> consEnergy=ConsThermo.dynamic <font color="darkgreen">&quot;Energy&quot;</font>;

  <font color="darkgreen">// Auxiliary variables (for analysis)</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_QT[n_trans](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = N*c_v*theta*kL ./ (2*Aprime) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Time constants for thermal transport (through the whole subregion)&quot;</font>;

  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Temperature">Q.Temperature</a> DeltaT[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">
    Delta</font>(boundaries.T) <font color="blue">if </font>environment.analysis <font color="darkgreen">
    &quot;Differences in temperatures across the boundaries&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.ThermalDiffusive">Connectors.ThermalDiffusive</a> boundaries[n_trans, Side](T(<font color="blue">each </font>start=T_IC)) <font color="darkgreen">
    &quot;Connectors for transport&quot;</font>;

<font color="blue">protected </font>
  <font color="blue">outer </font><a href="FCSys_Quantities.html#FCSys.Quantities.Area">Q.Area</a> Aprime[n_trans] <font color="darkgreen">&quot;Effective cross-sectional area&quot;</font>;

<font color="blue">equation </font>
  <font color="darkgreen">// Assumptions</font>
  phi = <font color="red">zeros</font>(n_trans) <font color="darkgreen">&quot;Zero velocity&quot;</font>;
  V = epsilon*<font color="red">product</font>(L) <font color="darkgreen">&quot;Prescribed volume&quot;</font>;

  <font color="darkgreen">// Equation of state</font>
  <font color="blue">if </font>Data.isCompressible<font color="blue"> then</font>
    p = <font color="red">Data.p_Tv</font>(T, v);
  <font color="blue">else</font>
    v = <font color="red">Data.v_Tp</font>(T, p);
  <font color="blue">end if</font>;

  <font color="darkgreen">// Thermal transport (conduction)</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_trans<font color="blue"> loop</font>
    <font color="blue">for </font>side<font color="blue"> in </font>Side<font color="blue"> loop</font>
      kL[i]*theta*boundaries[i, side].Qdot = 2*Aprime[i]*(boundaries[i, side].T -
        T);
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// Thermal dynamics</font>
  <font color="blue">if </font>consEnergy == ConsThermo.IC<font color="blue"> then</font>
    <font color="darkgreen">// Apply the IC forever (energy not conserved).</font>
    T = T_IC;
  <font color="blue">else</font>
    (<font color="blue">if </font>consEnergy == ConsThermo.dynamic<font color="blue"> then </font>N*T*<font color="red">der</font>(s)/U.s<font color="blue"> else </font>0) = <font color="red">sum</font>(
      intra[i].phi*intra[i].mPhidot <font color="blue">for </font>i<font color="blue"> in </font>1:n_intra) + <font color="red">sum</font>(inter[i].phi*
      inter[i].mPhidot <font color="blue">for </font>i<font color="blue"> in </font>1:n_inter) + <font color="red">sum</font>(intra.Qdot) + <font color="red">sum</font>(inter.Qdot) + <font color="red">
      sum</font>(boundaries.Qdot) <font color="darkgreen">&quot;Conservation of energy&quot;</font>;
  <font color="blue">end if</font>;

<font color="blue">end </font>Solid;
</pre>
<hr>

<h2><img src="images/FCSys.Species.SpeciesI.png" alt="FCSys.Species.Species" align=RIGHT border=1 width=80  height=80 >
<a name="FCSys.Species.Species"></a><a href="FCSys_Species.html#FCSys.Species">FCSys.Species</a>.Species</h2>
<b>Base model for one chemical species in one phase</b>
<img src="images/FCSys.Species.SpeciesD.png" alt="FCSys.Species.Species">

<h3>Information</h3>

<p>All of the details below are pertinent to the <a href="FCSys_Species.html#FCSys.Species.Fluid">Fluid</a>
    model (and the derived <a href="FCSys_Species.html#FCSys.Species.Ion">Ion</a> model) which inherits from this model.

    Only some of the details apply to the

    <a href="index.html#FCSys.Solid">Solid</a> model because it excludes the transport and exchange of

    material.</p>

    <p>This model is based on the following fixed assumptions:
    <ol>
       <li>All boundaries are rectangular.
       <li>The material is orthorhombic.  This implies that a gradient which induces diffusion
       along an axis does not induce diffusion along axes orthogonal to it
       [<a href="FCSys_UsersGuide_References.html#FCSys.UsersGuide.References.Bejan2006">Bejan2006</a>,
       pp.&nbsp;691&ndash;692].</li>
       <li>The coordinate system (x, y, z) is aligned with the principle
       axes of transport.  For example, if the material is stratified, then the
       layers must be parallel to one of the planes in the rectilinear
       grid.</li>
       <li>The effective transport lengths (<b><i>kL</i></b>)
          are common to material, translational, and thermal transport.</li>
       <li>There is no radiative heat transfer (or it must be linearized and added to the thermal conductance).</li>
       <li>Rotational momentum is not stored or transfered.</li>
    </ol>
    Other assumptions are optional via the parameters.  Additional assumptions may be

    applied in models that inherit from this one.</p>

    <p><a href="#Fig1">Figure 1</a> shows how instances of
    <a href="FCSys_Species.html#FCSys.Species">Species</a> models are
    connected within a <a href="FCSys_Subregions.html#FCSys.Subregions">Subregion</a>.  A single species in
    a single phase is called a <i>configuration</i>. The
    generalized resistances (<i>R</i>) affect the force and rates of chemical exchange and

    heat flow
    associated with differences in activity, velocity, and temperature (respectively) between
    each configuration and a common node.  These exchange processes are diffusive.
    Each resistor generates heat

    in the <a href="FCSys_Species.html#FCSys.Species">Species</a> instance that contains it.</p>

    <p align=center id="Fig1"><img src="images/Exchange.png">
<br>Figure 1:  Exchange of a quantity (material, translational momentum, or thermal energy) among configurations
    (A, B, and C) within a subregion.</p>

    <p><a href="#Fig2">Figure 2</a> shows how
    a configuration
    is connected between neighboring instances of a
    <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a>.
    Material, translational momentum, and thermal energy are transported by both advection and diffusion.
    Upstream discretization is applied if it is enabled via the <code>upstreamX</code>,
    etc. parameters.  Like for exchange, the transport resistances are inside the
    <a href="FCSys_Species.html#FCSys.Species">Species</a> model.</p>

    <p align=center id="Fig2"><img src="images/Transport.png">
<br>Figure 2:  Transport of a quantity associated with the same configuration
    between subregions (1 and 2).</p>

<p>The <a href="FCSys_Species.html#FCSys.Species">Species</a> instances
    within a <a href="FCSys_Phases.html#FCSys.Phases">Phase</a> are combined by Dalton's law of
    partial pressures (see the
    <a href="FCSys_Connectors.html#FCSys.Connectors.Dalton">Dalton</a> connector), as shown
    in Figure 3a.  The pressures are additive, and each species is assumed to exist at the
    total extensive volume of the phase.  Within a

    <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a>,
    the <a href="FCSys_Phases.html#FCSys.Phases">Phases</a> are combined by Amagat's law of partial volumes
    (see the <a href="FCSys_Connectors.html#FCSys.Connectors.Amagat">Amagat</a> connector), as shown
    in Figure 3b.  The volumes are additive, and each species is assumed to exist at the
    total pressure in the subregion.</p>

    <table border=0 cellspacing=0 cellpadding=2 align=center class=noBorder style="margin-left: auto; margin-right: auto;">
      <tr align=center class=noBorder>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="images/SharePressure.png">
<br>a:  Pressures of species (A, B, and C) are additive within a phase.
        </td>
        <td align=center class=noBorder style="margin-left: auto; margin-right: auto;">
          <img src="images/ShareVolume.png">
<br>b:  Volumes of phases (I, II, and III) are additive within a subregion.
        </td>
      </tr>
      <tr align=center class=noBorder style="margin-left: auto; margin-right: auto;">
        <td colspan=2 align=center class=noBorder>Figure 3: Methods of attributing pressure and volume.</td>
      </tr>
    </table>

    <p>Notes regarding the parameters:
    <ol>

    <li>The effective transport lengths (<b><i>kL</i></b>) may be different that the geometric lengths along the
    transport axes due to tortouisity.  The tortouisity may be anisotropic.</li>

    <li>If the interval for chemical exchange (&tau;&prime;), mobility (&mu;),
     thermal independity (&nu;), fluidity (&eta;), or thermal resistivity (&theta;)
      is zero, then
    it should usually be set as <code>final</code> so that index reduction may be performed.
    If two configurations
    are connected through their <code>intra</code>, <code>inter</code>, or <code>boundaries</code> connectors
    and both have zero generalized resistivities for a
    quantity, then index reduction [<a href="FCSys_UsersGuide_References.html#FCSys.UsersGuide.References.Mattsson1993">Mattsson1993</a>] is necessary.</li>

    <li>Even if an initialization parameter is not selected for explicit use,
    it may be used a guess value.</li>

    <li>If <code>ConsThermo.IC</code> is used for a state (via
    <code>consMaterial</code> or <code>consEnergy</code>),
    then the associated initial condition (IC) will be applied forever instead of the
    corresponding conservation equation.</li>

    <li>If <code>consEnergy</code> is
    <code>ConsThermo.steady</code>, then <i>N</i><i>T</i>&part;<i>s</i>/&part;<i>t</i> + <i>M</i>&phi;&part;&phi;/&part;<i>t</i> is treated as
    zero and removed from the energy balance.</li>

    <li>If a transport axis is not included (via the outer <code>inclTrans[:]</code> parameter
    which maps to <code>{inclTransX, inclTransY, inclTransZ}</code> in the
    <a href="FCSys_Subregions.html#FCSys.Subregions.Subregion">Subregion</a> model), then the associated pair of

    boundaries is removed from the model.</li>

    <li>The <code>start</code> values of the initial conditions for pressure and temperature
    (<i>p</i><sub>IC</sub> and <i>T</i><sub>IC</sub>) are the global default pressure and
    temperature (via the <code>outer</code> instance of the <a href="FCSys_Conditions.html#FCSys.Conditions.Environment">Environment</a> model).
    The <code>start</code> values of the initial conditions for
    other intensive properties (&rho;<sub>IC</sub>, <i>h</i><sub>IC</sub>, and
    <i>g</i><sub>IC</sub>) are related to the initial pressure and temperature
    by the characteristics of the species.  The <code>start</code> value of the
    initial condition for the extensive volume (<i>V</i><sub>IC</sub>) is the volume of the
    subregion.  The <code>start</code> value for particle number (<i>N</i><sub>IC</sub>)
    is related to it via the material characteristics and the initial pressure and temperature.
    In order to apply other values for any of these initial conditions,
    it may be necessary to do so before translating the model.</li></p>

    <p>In the <code>boundaries</code> connector array, the transverse translational flow (<i>m</i>&Phi;dot) is only the
    force due to diffusion.  Translational advection is calculated from the current and the velocity.
    The thermal flow (<i>Q&#775;</i>) is only the rate of heat transfer due to diffusion.  The advection of
    thermal energy is determined from the current and the thermodynamic state at the boundary.</p>

    <p>For the variables that relate to transport,
    the first index is the axis and the second index is the side.  The sides
    are ordered from negative to positive, according to the
    <a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.Side">Side</a> enumeration.
    Velocity and force are additionally indexed by
    the orientation of the momentum with respect to the boundary.
    The orientations are ordered following the normal axis in Cartesian space,
    according to the
    <a href="FCSys_Species_Enumerations.html#FCSys.Species.Enumerations.Orient">Orient</a> enumeration.</p>

<p>

<h3>Parameters</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Default</th><th>Description</th></tr>
<tr><td>Integer</td><td>n_inter</td><td>0</td><td>Number of exchange connections with other phases</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristics.BaseClasses&hellip;.</td><td>Characteristic data</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Mobility</a></td><td>mu</td><td>Data.mu(T, v)</td><td>Mobility [N.T/M]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">TimeAbsolute</a></td><td>nu</td><td>Data.nu(T, v)</td><td>Thermal independity [T]</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=4>Independence factors</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k_intra_Phi[n_intra, n_trans]</td><td>ones(n_intra, n_trans)</td><td>For translational exchange among species within the phase [1]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">NumberAbsolute</a></td><td>k_intra_Q[n_intra]</td><td>ones(n_intra)</td><td>For thermal exchange among species within the phase [1]</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Assumptions</b></td></tr>
<tr><td>Integer</td><td>n_trans</td><td>1</td><td>Number of transport axes</td></tr>
<TR bgcolor="#c0c0c0"><TD colspan=4><b>Initialization</b></td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Amount</a></td><td>N_IC</td><td>&nbsp;</td><td>Initial amount of material [N]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Density</a></td><td>rho_IC</td><td>&nbsp;</td><td>Initial density [N/L3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Volume</a></td><td>V_IC</td><td>&nbsp;</td><td>Initial volume [L3]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">PressureAbsolute</a></td><td>p_IC</td><td>&nbsp;</td><td>Initial pressure [M/(L.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">TemperatureAbsolute</a></td><td>T_IC</td><td>&nbsp;</td><td>Initial temperature [L2.M/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>h_IC</td><td>&nbsp;</td><td>Initial specific enthalpy [L2.M/(N.T2)]</td></tr>
<tr><td><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Potential</a></td><td>g_IC</td><td>&nbsp;</td><td>Initial Gibbs potential [L2.M/(N.T2)]</td></tr>
</table>
<p>

<h3>Connectors</h3>

<p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Type</th><th>Name</th><th>Description</th></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Intra">Intra</a></td><td>intra[n_intra]</td><td>Connectors to exchange translational momentum and energy within the phase</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Inter">Inter</a></td><td>inter[n_inter]</td><td>Connectors to exchange translational momentum and energy with all other species</td></tr>
<tr><td><a href="FCSys_Connectors.html#FCSys.Connectors.Dalton">Dalton</a></td><td>dalton</td><td>Connector for additivity of pressure</td></tr>
<TR bgcolor="#e0e0e0"><TD colspan=3>Material properties</td></tr>
<tr><TD colspan="2">replaceable package Data</td><td>Characteristic data</td></tr>
</table>

<h3>Modelica definition</h3>

<pre>
<font color="blue">partial </font><font color="blue">model</font> Species <font color="darkgreen">
  &quot;Base model for one chemical species in one phase&quot;</font>

  <font color="blue">import </font>assert = <a href="FCSys_Utilities.html#FCSys.Utilities.assertEval">FCSys.Utilities.assertEval</a>;

  <font color="darkgreen">// Material properties</font>
  <font color="blue">replaceable </font><font color="blue">package</font> Data = <a href="FCSys_Characteristics_BaseClasses_Characteristic.html#FCSys.Characteristics.BaseClasses.Characteristic">Characteristics.BaseClasses.Characteristic</a> <font color="blue">
    constrainedby </font>Characteristics.BaseClasses.Characteristic <font color="darkgreen">
    &quot;Characteristic data&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Mobility">Q.Mobility</a> mu(nominal=10*U.cm^2/(U.V*U.s)) = <font color="red">Data.mu</font>(T, v) <font color="darkgreen">&quot;Mobility&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> nu(nominal=1e-9*U.s) = <font color="red">Data.nu</font>(T, v) <font color="darkgreen">&quot;Thermal independity&quot;</font>;

  <font color="darkgreen">// Assumptions</font>
  <font color="blue">parameter </font>Integer n_trans=1 <font color="darkgreen">&quot;Number of transport axes&quot;</font>;
  <font color="darkgreen">// This can&#39;t be an outer parameter in Dymola 2014.</font>
  <font color="blue">parameter </font>Integer n_intra=0 <font color="darkgreen">&quot;Number of exchange connections within the phase&quot;</font>;
  <font color="blue">parameter </font>Integer n_inter=0 <font color="darkgreen">
    &quot;Number of exchange connections with other phases&quot;</font>;

  <font color="darkgreen">// Initialization parameters</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N_IC(start=V_IC*rho_IC) <font color="darkgreen">&quot;Initial amount of material&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Q.Density</a> rho_IC(start=1/<font color="red">Data.v_Tp</font>(T_IC, p_IC)) <font color="darkgreen">&quot;Initial density&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V_IC(start=<font color="red">product</font>(L)) <font color="darkgreen">&quot;Initial volume&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p_IC(start=environment.p) <font color="darkgreen">&quot;Initial pressure&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T_IC(start=environment.T) <font color="darkgreen">
    &quot;Initial temperature&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h_IC(start=<font color="red">Data.h</font>(T_IC, p_IC), displayUnit=&quot;kJ/mol&quot;) <font color="darkgreen">
    &quot;Initial specific enthalpy&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> g_IC(start=<font color="red">Data.g</font>(T_IC, p_IC), displayUnit=&quot;kJ/mol&quot;) <font color="darkgreen">
    &quot;Initial Gibbs potential&quot;</font>;

  <font color="darkgreen">// Independence factors</font>
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> k_intra_Phi[n_intra, n_trans]=<font color="red">ones</font>(n_intra,
      n_trans) <font color="darkgreen">&quot;For translational exchange among species within the phase&quot;</font>;
  <font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> k_intra_Q[n_intra]=<font color="red">ones</font>(n_intra) <font color="darkgreen">
    &quot;For thermal exchange among species within the phase&quot;</font>;

  <font color="darkgreen">// Preferred states</font>
  <font color="darkgreen">// Note:  The start values for these variable aren&#39;t fixed because the</font>
  <font color="darkgreen">// initial equation section will be used instead.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> N(
    <font color="blue">final </font>min=Modelica.Constants.small,
    nominal=4*U.C,
    <font color="blue">final </font>start=N_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Amount of material&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.TemperatureAbsolute">Q.TemperatureAbsolute</a> T(
    nominal=300*U.K,
    <font color="blue">final </font>start=T_IC,
    stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Temperature&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Velocity">Q.Velocity</a> phi[n_trans](
    <font color="blue">each </font>nominal=100*U.cm/U.s,
    <font color="blue">each </font>start=0,
    <font color="blue">each </font>stateSelect=StateSelect.prefer) <font color="darkgreen">&quot;Velocity&quot;</font>;

  <font color="darkgreen">// Aliases (for common terms)</font>
  <font color="darkgreen">// Note:  StateSelect.never helps avoid dynamic state selection of these</font>
  <font color="darkgreen">// variables in Dymola 2014.</font>
  <a href="FCSys_Quantities.html#FCSys.Quantities.PressureAbsolute">Q.PressureAbsolute</a> p(
    nominal=U.atm,
    <font color="blue">final </font>start=p_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Pressure&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> g(
    nominal=U.V,
    <font color="blue">final </font>start=g_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Specific Gibbs energy&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Mass">Q.Mass</a> M(
    nominal=1e-3*U.g,
    <font color="blue">final </font>start=Data.m*N_IC,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Mass&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.VolumeSpecific">Q.VolumeSpecific</a> v(
    nominal=U.cc/(4*U.C),
    <font color="blue">final </font>start=1/rho_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Specific volume&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.Potential">Q.Potential</a> h(
    nominal=U.V,
    <font color="blue">final </font>start=h_IC,
    <font color="blue">final </font>fixed=false,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Specific enthalpy&quot;</font>;
  <a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> s(
    nominal=25,
    <font color="blue">final </font>start=(h_IC - g_IC)/T_IC,
    stateSelect=StateSelect.never) <font color="darkgreen">&quot;Specific entropy&quot;</font>;

  <font color="darkgreen">// Auxiliary variables (for analysis)</font>
  <font color="darkgreen">// ----------------------------------</font>
  <font color="darkgreen">// Thermodynamic properties</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Density">Q.Density</a> rho(stateSelect=StateSelect.never) = 1/v <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Density&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.MassVolumic">Q.MassVolumic</a> mrho(stateSelect=StateSelect.never) = Data.m*rho <font color="blue">if </font>
    environment.analysis <font color="darkgreen">&quot;Volumic mass&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Amount">Q.Amount</a> S(stateSelect=StateSelect.never) = N*s <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Entropy&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.CapacityThermalSpecific">Q.CapacityThermalSpecific</a> c_p(stateSelect=StateSelect.never) = <font color="red">
    Data.c_p</font>(T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Isobaric specific heat capacity&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.CapacityThermalSpecific">Q.CapacityThermalSpecific</a> c_v(stateSelect=StateSelect.never) = <font color="red">
    Data.c_v</font>(T, p) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Isochoric specific heat capacity&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.PressureReciprocal">Q.PressureReciprocal</a> beta(stateSelect=StateSelect.never) = <font color="red">Data.beta</font>(T,
    p) <font color="blue">if </font>environment.analysis <font color="darkgreen">&quot;Isothermal compressibility&quot;</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Time constants</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_PhiE_intra[n_intra, n_trans](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = {Data.m*mu*k_intra_Phi[i, :] <font color="blue">for </font>i<font color="blue"> in </font>1:n_intra} <font color="blue">if </font>
    environment.analysis<font color="blue"> and </font>n_intra &gt; 0 <font color="darkgreen">
    &quot;Time constants for translational intra-phase exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_PhiE_inter[n_inter, n_trans](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = {Data.m*mu*k_inter_Phi[i, :] <font color="blue">for </font>i<font color="blue"> in </font>1:n_inter} <font color="blue">if </font>
    environment.analysis<font color="blue"> and </font>n_inter &gt; 0 <font color="darkgreen">
    &quot;Time constants for translational inter-phase exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_QE_intra[n_intra](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = c_p*nu*k_intra_Q <font color="blue">if </font>environment.analysis<font color="blue"> and </font>n_intra &gt; 0 <font color="darkgreen">
    &quot;Time constants for thermal intra-phase exchange&quot;</font>;
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.TimeAbsolute">Q.TimeAbsolute</a> tau_QE_inter[n_inter](
    <font color="blue">each </font>stateSelect=StateSelect.never,
    <font color="blue">each </font>start=U.s) = c_p*nu*k_inter_Q <font color="blue">if </font>environment.analysis<font color="blue"> and </font>n_inter &gt; 0 <font color="darkgreen">
    &quot;Time constants for thermal inter-phase exchange&quot;</font>;
  <font color="darkgreen">// Note:  The structure of the problem should not change if these auxiliary</font>
  <font color="darkgreen">// variables are included (hence, StateSelect.never).</font>
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Translational momentum balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Force">Q.Force</a> f_DE[n_trans](<font color="blue">each </font>stateSelect=StateSelect.never) = <font color="red">sum</font>(intra[
    i].mPhidot <font color="blue">for </font>i<font color="blue"> in </font>1:n_intra) + <font color="red">sum</font>(inter[i].mPhidot <font color="blue">for </font>i<font color="blue"> in </font>1:n_inter) <font color="blue">
    if </font>environment.analysis <font color="darkgreen">
    &quot;Friction from other configurations (diffusive exchange)&quot;</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// Energy balance</font>
  <font color="blue">output </font><a href="FCSys_Quantities.html#FCSys.Quantities.Power">Q.Power</a> Edot_DE(stateSelect=StateSelect.never) = <font color="red">sum</font>(intra[i].phi*
    intra[i].mPhidot <font color="blue">for </font>i<font color="blue"> in </font>1:n_intra) + <font color="red">sum</font>(inter[i].phi*inter[i].mPhidot <font color="blue">
    for </font>i<font color="blue"> in </font>1:n_inter) + <font color="red">sum</font>(intra.Qdot) + <font color="red">sum</font>(inter.Qdot) <font color="blue">if </font>environment.analysis
    <font color="darkgreen">&quot;Rate of diffusion of energy from other configurations&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Intra">Connectors.Intra</a> intra[n_intra](<font color="blue">each </font><font color="blue">final </font>n_trans=n_trans, <font color="blue">each </font>T(<font color="blue">final </font>
        start=T_IC, <font color="blue">final </font>fixed=false)) <font color="darkgreen">
    &quot;Connectors to exchange translational momentum and energy within the phase&quot;</font>;
  <a href="FCSys_Connectors.html#FCSys.Connectors.Inter">Connectors.Inter</a> inter[n_inter](<font color="blue">each </font><font color="blue">final </font>n_trans=n_trans, <font color="blue">each </font>T(<font color="blue">final </font>
        start=T_IC, <font color="blue">final </font>fixed=false)) <font color="darkgreen">
    &quot;Connectors to exchange translational momentum and energy with all other species&quot;</font>;

  <a href="FCSys_Connectors.html#FCSys.Connectors.Dalton">Connectors.Dalton</a> dalton(V(
      min=0,
      <font color="blue">final </font>start=V_IC,
      <font color="blue">final </font>fixed=false), p(<font color="blue">final </font>start=p_IC, <font color="blue">final </font>fixed=false)) <font color="darkgreen">
    &quot;Connector for additivity of pressure&quot;</font>;

  <font color="darkgreen">// Geometric parameters</font>

<font color="blue">protected </font>
  <font color="blue">outer </font><a href="FCSys_Quantities.html#FCSys.Quantities.Volume">Q.Volume</a> V <font color="darkgreen">&quot;Volume of the phase (not of the subregion)&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.Length">Q.Length</a> L[Axis] <font color="darkgreen">&quot;Lengths of the subregion&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font>Integer cartTrans[:] <font color="darkgreen">
    &quot;Cartesian-axis indices of the transport axes&quot;</font>;
  <font color="darkgreen">// Note:  The size of cartTrans is n_trans, but it can&#39;t be specified here</font>
  <font color="darkgreen">// due to an error in Dymola 2014.</font>
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> k_inter_Phi[:, :] <font color="darkgreen">
    &quot;Independence factors for translational exchange with other phases&quot;</font>;
  <font color="blue">outer </font><font color="blue">parameter </font><a href="FCSys_Quantities.html#FCSys.Quantities.NumberAbsolute">Q.NumberAbsolute</a> k_inter_Q[:] <font color="darkgreen">
    &quot;Independence factors for thermal exchange among with other phases&quot;</font>;
  <font color="darkgreen">// Note:  The sizes can&#39;t be specified due to an error in Dymola 2014.</font>

  <font color="blue">outer </font><a href="FCSys_Conditions.html#FCSys.Conditions.Environment">Conditions.Environment</a> environment <font color="darkgreen">&quot;Environmental conditions&quot;</font>;

<font color="blue">initial </font><font color="blue">equation </font>
  <font color="darkgreen">// Check the initial conditions.</font>
  <font color="red">assert</font>(V &gt;= 0, &quot;The volume of &quot; + <font color="red">getInstanceName</font>() + &quot; is negative.
Check that the volumes of the other phases are set properly.&quot;);

<font color="blue">equation </font>
  <font color="darkgreen">// Aliases (only to clarify and simplify other equations)</font>
  h = g + T*s;
  p = dalton.p;
  v*N = dalton.V;
  M = Data.m*N;

  <font color="darkgreen">// Thermodynamic correlations</font>
  h = <font color="red">Data.h</font>(T, p);
  s = <font color="red">Data.s</font>(T, p);

  <font color="darkgreen">// Exchange</font>
  <font color="darkgreen">// --------</font>
  <font color="darkgreen">// Within the phase</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_intra<font color="blue"> loop</font>
    k_intra_Phi[i, :]*mu .* intra[i].mPhidot = N*(intra[i].phi - phi) <font color="darkgreen">
      &quot;Translational&quot;</font>;
    k_intra_Q[i]*nu*intra[i].Qdot = N*(intra[i].T - T) <font color="darkgreen">&quot;Thermal&quot;</font>;
  <font color="blue">end for</font>;
  <font color="darkgreen">// </font>
  <font color="darkgreen">// With other phases</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_inter<font color="blue"> loop</font>
    k_inter_Phi[i, :]*mu .* inter[i].mPhidot = N*(inter[i].phi - phi) <font color="darkgreen">
      &quot;Translational&quot;</font>;
    k_inter_Q[i]*nu*inter[i].Qdot = N*(inter[i].T - T) <font color="darkgreen">&quot;Thermal&quot;</font>;
  <font color="blue">end for</font>;

<font color="blue">end </font>Species;
</pre>
      </div>
    </div>
  </div>
</div>
<div class="footer">
  Copyright &copy; 2007&ndash;2014, Kevin Davies, Hawaii Natural Energy Institute. Last updated Thu Jan 23 09:06:56 2014.
</div>
</span></body></html>
